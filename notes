Brute-force align string matching algorithm

shift=-4 (1-len(read2))
    ABCDEFGHIJ
ABCDE
0->1
4->5

shift=-3
    ABCDEFGHIJ
 ABCDE
0->2
3->5

shift=2
    ABCDEFGHIJ
      ABCDE
2->7
0->5

shift=3
    ABCDEFGHIJ
       ABCDE
3->8
0->5

shift=6
    ABCDEFGHIJ
          ABCDE
6->10
0->4

shift=7
    ABCDEFGHIJ
           ABCDE
7->10
0->3

shift=9
    ABCDEFGHIJ
             ABCDE
9->10
0->1

So:
shift: range(1-len(read2),len(read1))
read1: max(0,shift), min(len(read1),shift+len(read2))
read2: max(0,-shift), min(len(read2),len(read1)-shift)

---

merging algorithm:
['KLMNOPQRST', 'CDEFGHIJK', 'CDEFGHIJK', 'NOPQRSTU', 'RSTUVWXY', 'CDEFGHIJ', 'GHIJKLMN', 'ABCDEFGH', 'PQRSTUV', 'OPQRS']

[0, -8, -8, 3, 7, 10, -4, 10, 5, 4]
[-8, 0, 0, 9, 9, 0, 4, -2, 9, 9]
[-8, 0, 0, 9, 9, 0, 4, -2, 9, 9]
[3, 9, 9, 0, 4, 8, -7, 8, 2, 1]
[7, 9, 9, 4, 0, 8, 8, 8, -2, -3]
[10, 0, 0, 8, 8, 0, 4, -2, 8, 8]
[-4, 4, 4, -7, 8, 4, 0, -6, 8, 8]
[10, -2, -2, 8, 8, -2, -6, 0, 8, 8]
[5, 9, 9, 2, -2, 8, 8, 8, 0, -1]
[4, 9, 9, 1, -3, 8, 8, 8, -1, 0]


arr=
   0   1  2  3  4  5  6  7  8  9
0 [-1, 1, 1, 7, 3, 0, 4, 0, 5, 5]
1 [1, -1, 9, 0, 0, 8, 5, 6, 0, 0]
2 [1, 9, -1, 0, 0, 8, 5, 6, 0, 0]
3 [7, 0, 0, -1, 4, 0, 1, 0, 6, 5]
4 [3, 0, 0, 4, -1, 0, 0, 0, 5, 2]
5 [0, 8, 8, 0, 0, -1, 4, 6, 0, 0]
6 [4, 5, 5, 1, 0, 4, -1, 2, 0, 0]
7 [0, 6, 6, 0, 0, 6, 2, -1, 0, 0]
8 [5, 0, 0, 6, 5, 0, 0, 0, -1, 4]
9 [5, 0, 0, 5, 2, 0, 0, 0, 4, -1]

find global max: 9
Remove smaller pair (higher num), insert into align_arr with smaller num first
align_arr = [[1,2]]
Remove 2
arr=
    0  1  3  4  5  6  7  8  9
0 [-1, 1, 7, 3, 0, 4, 0, 5, 5]
1 [1, -1, 0, 0, 8, 5, 6, 0, 0]
3 [7, 0, -1, 4, 0, 1, 0, 6, 5]
4 [3, 0, 4, -1, 0, 0, 0, 5, 2]
5 [0, 8, 0, 0, -1, 4, 6, 0, 0]
6 [4, 5, 1, 0, 4, -1, 2, 0, 0]
7 [0, 6, 0, 0, 6, 2, -1, 0, 0]
8 [5, 0, 6, 5, 0, 0, 0, -1, 4]
9 [5, 0, 5, 2, 0, 0, 0, 4, -1]

find global max: 8
align_arr = [[1,2],[1,5]]
arr=
    0  1  3  4  6  7  8  9
0 [-1, 1, 7, 3, 4, 0, 5, 5]
1 [1, -1, 0, 0, 5, 6, 0, 0]
3 [7, 0, -1, 4, 1, 0, 6, 5]
4 [3, 0, 4, -1, 0, 0, 5, 2]
6 [4, 5, 1, 0, -1, 2, 0, 0]
7 [0, 6, 0, 0, 2, -1, 0, 0]
8 [5, 0, 6, 5, 0, 0, -1, 4]
9 [5, 0, 5, 2, 0, 0, 4, -1]
find global max: 7
align_arr = [[1,2],[1,5],[0,3]]
    0  1  4  6  7  8  9
0 [-1, 1, 3, 4, 0, 5, 5]
1 [1, -1, 0, 5, 6, 0, 0]
4 [3, 0, -1, 0, 0, 5, 2]
6 [4, 5, 0, -1, 2, 0, 0]
7 [0, 6, 0, 2, -1, 0, 0]
8 [5, 0, 5, 0, 0, -1, 4]
9 [5, 0, 2, 0, 0, 4, -1]

gmax:6
align_arr = [[1,2],[1,5],[0,3],[1,7]]
    0  1  4  6  8  9
0 [-1, 1, 3, 4, 5, 5]
1 [1, -1, 0, 5, 0, 0]
4 [3, 0, -1, 0, 5, 2]
6 [4, 5, 0, -1, 0, 0]
8 [5, 0, 5, 0, -1, 4]
9 [5, 0, 2, 0, 4, -1]

gmax:5
align_arr = [[1,2],[1,5],[0,3],[1,7],[0,8]]
    0  1  4  6  9
0 [-1, 1, 3, 4, 5]
1 [1, -1, 0, 5, 0]
4 [3, 0, -1, 0, 2]
6 [4, 5, 0, -1, 0]
9 [5, 0, 2, 0, -1]

gmax:5
align_arr = [[1,2],[1,5],[0,3],[1,7],[0,8],[0,9]]
    0  1  4  6
0 [-1, 1, 3, 4]
1 [1, -1, 0, 5]
4 [3, 0, -1, 0]
6 [4, 5, 0, -1]

gmax:4
align_arr = [[1,2],[1,5],[0,3],[1,7],[0,8],[0,9],[0,6]]
    0  1  4
0 [-1, 1, 3]
1 [1, -1, 0]
4 [3, 0, -1]

gmax:3
align_arr = [[1,2],[1,5],[0,3],[1,7],[0,8],[0,9],[0,6],[0,4]]
    0  1
0 [-1, 1]
1 [1, -1]

gmax:1
align_arr = [[1,2],[1,5],[0,3],[1,7],[0,8],[0,9],[0,6],[0,4],[0,1]]

Iterate align_arr and create merglets, ordering within merglets based on shifts
A new merglet's first item has shift 0, the rest found from shift_arr based off
    this first item

[1,2]
(1(0),2(0))

[1,5]
(1(0),2(0),5(0))

[0,3]
(1(0),2(0),5(0)),(0(0),3(3))

[1,7]
(7(-2),1(0),2(0),5(0)),(0(0),3(3))

[0,8]
(7(-2),1(0),2(0),5(0)),(0(0),3(3),8(5))

[0,9]
(7(-2),1(0),2(0),5(0)),(0(0),3(3),9(4),8(5))

[0,6]
(7(-2),1(0),2(0),5(0)),(6(-4),0(0),3(3),9(4),8(5))

[0,4]
(7(-2),1(0),2(0),5(0)),(6(-4),0(0),3(3),9(4),8(5),4(7))

[0,1]
Now we must combine merglets:
the shift between 0 and is -8, so to merge 0 into 1, we must add 8
6(4),0(8),3(11),9(12),8(13),4(15)

Then merge in order:
7(-2),1(0),2(0),5(0),6(4),0(8),3(11),9(12),8(13),4(15)

Then we can generate the original string

---

Merging mergelets:
0 1
1 3
1 2
8 9

After 0 1 merge, subtract 1 from all >= 1
0 2
0 1
7 8

After 0 2 merge, subtract 1 from all >= 2
0 1
6 7

After 0 1 merge, subtract 1 from all >= 1
5 6

Another example:
[0 1 2 3]
2 3
1 2
0 3

After 2 3 merge, subtract 1 from all >= 3
[0 1 23]
1 2
0 2

After 1 2 merge, subtract 1 from all >= 2
[0 123]
0 1

Another:
[0 1 2 3]
1 2
0 3
0 1

[0 12 3]
0 2
0 1

[0 123]
0 1

---

This output is erroneous, and didn't align reads correctly:

Length-sorted reads:
['MNOPQRSTUV', 'NOPQRSTUVW', 'EFGHIJKLMN', 'EFGHIJKLMN', 'QRSTUVWXY', 'QRSTUVWX', 'DEFGHIJK', 'CDEFGH', 'GHIJK', 'NOPQR']

Alignment-score array:
[-1, 9, 2, 2, 6, 6, 0, 0, 0, 5]
[9, -1, 1, 1, 7, 7, 0, 0, 0, 5]
[2, 1, -1, 10, 0, 0, 7, 4, 5, 1]
[2, 1, 10, -1, 0, 0, 7, 4, 5, 1]
[6, 7, 0, 0, -1, 8, 0, 0, 0, 2]
[6, 7, 0, 0, 8, -1, 0, 0, 0, 2]
[0, 0, 7, 7, 0, 0, -1, 5, 5, 0]
[0, 0, 4, 4, 0, 0, 5, -1, 2, 0]
[0, 0, 5, 5, 0, 0, 5, 2, -1, 0]
[5, 5, 1, 1, 2, 2, 0, 0, 0, -1]

Alignment order:
[(2, 3), (0, 1), (4, 5), (2, 6), (0, 4), (0, 9), (2, 8), (2, 7), (0, 2)]

Alignment-score's corresponding shift array
[0, 1, -8, -8, 4, 4, 10, 10, 10, 1]
[-1, 0, -9, -9, 3, 3, 10, 10, 10, 0]
[8, 9, 0, 0, 10, 10, -1, -2, 2, 9]
[8, 9, 0, 0, 10, 10, -1, -2, 2, 9]
[-4, -3, -10, -10, 0, 0, 9, 9, 9, -3]
[-4, -3, -10, -10, 0, 0, 8, 8, 8, -3]
[-10, -10, 1, 1, -9, -8, 0, -1, 3, 8]
[-10, -10, 2, 2, -9, -8, 1, 0, 4, 6]
[-10, -10, -2, -2, -9, -8, -3, -4, 0, 5]
[-1, 0, -9, -9, 3, 3, -8, -6, -5, 0]

Alignment succession:
[[(2, 0), (3, 0)]]
[[(2, 0), (3, 0)], [(0, 0), (1, 1)]]
[[(2, 0), (3, 0)], [(0, 0), (1, 1)], [(4, 0), (5, 0)]]
[[(6, -1), (2, 0), (3, 0)], [(0, 0), (1, 1)], [(4, 0), (5, 0)]]
[[(6, -1), (2, 0), (3, 0)], [(0, 0), (1, 1), (4, 4)], [(4, 0), (5, 0)]]
[[(6, -1), (2, 0), (3, 0)], [(0, 0), (1, 1), (9, 1), (4, 4)], [(4, 0), (5, 0)]]
[[(6, -1), (2, 0), (3, 0), (8, 2)], [(0, 0), (1, 1), (9, 1), (4, 4)], [(4, 0), (5, 0)]]
[[(7, -2), (6, -1), (2, 0), (3, 0), (8, 2)], [(0, 0), (1, 1), (9, 1), (4, 4)], [(4, 0), (5, 0)]]
[[(7, -2), (6, -1), (2, 0), (3, 0), (8, 2)], [(2, -8), (0, 0), (1, 1), (9, 1), (4, 4)], [(4, 0), (5, 0)]]

Merging mergelets:
[[1, 2, 4], [0, 1, 0]]
[[0, 1, 0]]

Final mergelet array: 
[[(7, -2), (6, -1), (2, 0), (3, 0), (8, 2)], [(2, -8), (0, 0), (1, 1), (9, 1), (4, 4), (5, 4)]]

Aligned-reads array: 
('CDEFGHIJKLMN', [['C'], ['D', 'D'], ['E', 'E', 'E', 'E'], ['F', 'F', 'F', 'F'], ['G', 'G', 'G', 'G', 'G'], ['H', 'H', 'H', 'H', 'H'], ['I', 'I', 'I', 'I'], ['J', 'J', 'J', 'J'], ['K', 'K', 'K', 'K'], ['L', 'L'], ['M', 'M'], ['N', 'N']], [('CDEFGH', 0), ('DEFGHIJK', 1), ('EFGHIJKLMN', 2), ('EFGHIJKLMN', 2), ('GHIJK', 4)])

('EFGHIJKLMNOPQRSTUVWXY', [['E'], ['F'], ['G'], ['H'], ['I'], ['J'], ['K'], ['L'], ['M', 'M'], ['N', 'N', 'N', 'N'], ['O', 'O', 'O'], ['P', 'P', 'P'], ['Q', 'Q', 'Q', 'Q', 'Q'], ['R', 'R', 'R', 'R', 'R'], ['S', 'S', 'S', 'S'], ['T', 'T', 'T', 'T'], ['U', 'U', 'U', 'U'], ['V', 'V', 'V', 'V'], ['W', 'W', 'W'], ['X', 'X'], ['Y']], [('EFGHIJKLMN', 0), ('MNOPQRSTUV', 8), ('NOPQRSTUVW', 9), ('NOPQR', 9), ('QRSTUVWXY', 12), ('QRSTUVWX', 12)])

Let's take a look at the mergelet arrays

Before merging:
[[7,6,2,3,8],[2,0,1,9,4],[4,5]]

Merging mergelets:
[[1, 2, 4], [0, 1, 0]]
[[0, 1, 0]]

After merging:
[[7,6,2,3,8],[2,0,1,9,4,5]]

The last merge, [[0, 1, 0]], doesn't happen... why?

solution: 
...
mergelet_arr.remove(mergelet_arr[ml2])
merge_mergelets.remove([ml1,ml2,all_shift])
...

Don't remove the mergelets between rounds. Causes a shifting error or something

---

Major bug/design issue:

The way I do as many align-orders as reads is totally wrong. Especially removing
the rows/columns between rounds. Look at the following, where ABCDEFG could
align with the rest of the reads but doesn't:

Length-sorted reads:
['OPQRSTUVWX', 'MNOPQRSTUV', 'OPQRSTUVW', 'HIJKLMNOP', 'GHIJKLMNO', 'IJKLMNOPQ', 'NOPQRSTU', 'QRSTUVW', 'ABCDEFG', 'RSTUVW']

Alignment-score array:
[-1, 8, 9, 2, 1, 3, 7, 7, 0, 6]
[8, -1, 8, 4, 3, 5, 8, 6, 0, 5]
[9, 8, -1, 2, 1, 3, 7, 7, 0, 6]
[2, 4, 2, -1, 8, 8, 3, 0, 0, 0]
[1, 3, 1, 8, -1, 7, 2, 0, 1, 0]
[3, 5, 3, 8, 7, -1, 4, 1, 0, 0]
[7, 8, 7, 3, 2, 4, -1, 5, 0, 4]
[7, 6, 7, 0, 0, 1, 5, -1, 0, 6]
[0, 0, 0, 0, 1, 0, 0, 0, -1, 0]
[6, 5, 6, 0, 0, 0, 4, 6, 0, -1]

Alignment order:
[(0, 2), (0, 1), (3, 4), (3, 5), (0, 6), (0, 7), (0, 9), (0, 3), (10, 8)]

Alignment-score's corresponding shift array
[0, -2, 0, -7, -8, -6, -1, 2, 10, 3]
[2, 0, 2, -5, -6, -4, 1, 4, 10, 5]
[0, -2, 0, -7, -8, -6, -1, 2, 9, 3]
[7, 5, 7, 0, -1, 1, 6, 9, 9, 9]
[8, 6, 8, 1, 0, 2, 7, 9, -6, 9]
[6, 4, 6, -1, -2, 0, 5, 8, 9, 9]
[1, -1, 1, -6, -7, -5, 0, 3, 8, 4]
[-2, -4, -2, -9, -9, -8, -3, 0, 7, 1]
[-10, -10, -9, -9, 6, -9, -8, -7, 0, 7]
[-3, -5, -3, -9, -9, -9, -4, -1, -7, 0]

Alignment succession:
[[(0, 0), (2, 0)]]
[[(1, -2), (0, 0), (2, 0)]]
[[(1, -2), (0, 0), (2, 0)], [(4, -1), (3, 0)]]
[[(1, -2), (0, 0), (2, 0)], [(4, -1), (3, 0), (5, 1)]]
[[(1, -2), (6, -1), (0, 0), (2, 0)], [(4, -1), (3, 0), (5, 1)]]
[[(1, -2), (6, -1), (0, 0), (2, 0), (7, 2)], [(4, -1), (3, 0), (5, 1)]]
[[(1, -2), (6, -1), (0, 0), (2, 0), (7, 2), (9, 3)], [(4, -1), (3, 0), (5, 1)]]
[[(3, -7), (1, -2), (6, -1), (0, 0), (2, 0), (7, 2), (9, 3)], [(4, -1), (3, 0), (5, 1)]]
[[(3, -7), (1, -2), (6, -1), (0, 0), (2, 0), (7, 2), (9, 3)], [(4, -1), (3, 0), (5, 1)], [(8, 0)]]

Merging mergelets:
[[0, 1, -7]]
[[0, 0, -7]]

Final mergelet array: 
[[(4, -8), (3, -7), (5, -6), (1, -2), (6, -1), (0, 0), (2, 0), (7, 2), (9, 3)], [(8, 0)]]

Aligned-reads array: 
('GHIJKLMNOPQRSTUVWX', [['G'], ['H', 'H'], ['I', 'I', 'I'], ['J', 'J', 'J'], ['K', 'K', 'K'], ['L', 'L', 'L'], ['M', 'M', 'M', 'M'], ['N', 'N', 'N', 'N', 'N'], ['O', 'O', 'O', 'O', 'O', 'O', 'O'], ['P', 'P', 'P', 'P', 'P', 'P'], ['Q', 'Q', 'Q', 'Q', 'Q', 'Q'], ['R', 'R', 'R', 'R', 'R', 'R'], ['S', 'S', 'S', 'S', 'S', 'S'], ['T', 'T', 'T', 'T', 'T', 'T'], ['U', 'U', 'U', 'U', 'U', 'U'], ['V', 'V', 'V', 'V', 'V'], ['W', 'W', 'W', 'W'], ['X']], [('GHIJKLMNO', 0), ('HIJKLMNOP', 1), ('IJKLMNOPQ', 2), ('MNOPQRSTUV', 6), ('NOPQRSTU', 7), ('OPQRSTUVWX', 8), ('OPQRSTUVW', 8), ('QRSTUVW', 10), ('RSTUVW', 11)])

('ABCDEFG', [['A'], ['B'], ['C'], ['D'], ['E'], ['F'], ['G']], [('ABCDEFG', 0)])


Still, given this data set I'd be hesitant to say that ABCDEFG is actually aligned
with the rest, since it only overlaps on the G.

Still, this method is a just an approximation of things, not a global maximum,
and its accuracy is not very clear.

